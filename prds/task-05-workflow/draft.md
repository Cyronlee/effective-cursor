在章节4-workflow中，分享我们团队日常工作流实践，包含几种cursor使用的模式

## 核心关注点
- Tasking, designing, coding for accuracy
- AI-assisted development, human-focused innovation

在章节3-cursor-rules中，使用rules约束了AI生成代码的边界，并配置了自动化检测和修复，有了这些保障，下面的任何一种使用方式（mode）都可以产出高质量的代码

## cursor agent主要分为四种模式(mode)

先在一个文章中介绍我们团队中这四个模式的使用占比，然后将2,3,4单独作为文章详细介绍，每个详细介绍中使用mermaid绘制流程图

### 1. Manual mode（手动模式）
- 描述：传统手动开发
- 使用比例：约 10%
- 典型场景：
  - 细节调整
  - 配置修改
  - 等等

一个项目中技术栈不同，开发的内容不同，个人习惯不同，有时是需要手动修改一些代码

### 2. Direct mode（直接模式）
- 描述：直接聊天并使用 @file 来启动生成
- 使用比例：约 32%
- 典型场景：
  - 快速验证
  - 简单重构、需求
  - 修复bug
  - 等等

这个模式是大多数人上手用cursor的默认模式，chat比较灵活，一般简单需求一次就可以完成，也可以一直chat修改代码

但是问题也比较多：
- 难以在chat小窗口中以规范的格式排版、分割细节
- 每次继续聊天都会消耗一次request，消耗过多token
- 如果在一个conversation中聊了很多，上下文混乱质量会越来越差
- 太依赖agent检索上下文的能力，如果技术细节不明确，有些上下文获取不到（agent一般只会检索top-n的上下文），发现比较滞后
- 难以记录每次chat的prompt，导致无法沉淀

常用例子：
- 运行`./gradew test`然后修复错误

### 3. Document mode（文档模式）
- 描述：编写结构化的需求文档，用于后续任务拆分
- 使用比例：约 22%
- 典型场景：
  - 需要用markdown给出一些参考，例如api结构、sdk示例等
  - 适用于复杂业务逻辑
  - 工作量较大，需要agent进行设计拆分

这个文档的目的是记录，可以是很简单的需求，很乱的排版，也可以是通过聊天得出的结构化的需求文档

解决了Direct mode的问题
- 可以以规范的格式排版、分割细节
- 可以记录prompt，供其他开发者参考，逐渐作为沉淀

### 4. Draft-Final mode（Draft→Final 模式）
- 描述：先把粗糙的 draft.md 交给 AI，让它自己获取上下文，完善成适合项目的 final.md 解决方案
- 使用比例：约 36%（最高）
- 典型场景：
  - 复杂业务逻辑的任务拆分
  - 对不熟悉的领域进行开发

其实和3很像，但是这种模式一定会产出一个详细的final.md，这可以让开发者生成代码之前就有全局的视野，可以调整final再生成代码，在我们的实践中，一般3次request就可以完成一个复杂
为什么引入 draft，Draft也是很有价值的，相当于记录了不同开发者的思路，这对新人学习很有帮助

## 管理知识

目前我们还没有使用动态知识库功能（例如cursor docs、 memory或第三方memory库），我们还在探索中
因此我们推荐在prompts中按需添加doc.md, design.png, example-query.sql 文件，如果比较通用，可以维护在单独的文件夹中便于引用

## 工作流实践

- 需求拆分task
- 梳理所需的文档、设计图等作为task的参考文档
- 编写task draft.md，设计架构、结构、流程
- draft+参考文档+agent=final
- final调整
- 生成代码
- review、自测、循环
