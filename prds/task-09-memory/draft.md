写一篇文章"使用 Rules 管理记忆"

我们在cursor也是用了类似的方式管理记忆，没有选择embedding，而是在.memory目录下维护了一个大目录.md然后link到零散的记忆.md 因为现在cursor已经没有25次tool call限制了，感觉读取本地文件做渐进式披露是一个性价比比较高的事情，尤其是用了opus模型，在一次请求中用掉尽量多的上下文比较划算

## 文章结构

1. **你是否需要记忆** - 一般来讲rules就足够了，每次生成引入了哪些rules是比较确定的，但是记忆是渐进式披露的，也就是agent根据需要读取，但agent可能不一定会读取到所有你希望它读取的记忆，这也是为什么我们的实践的rules和draft-final都更推荐手动，这样会更有信心

2. **本地记忆实践** - 讲述我们使用本地memory的实践，给出本地记忆的示例

3. **Rules 中的记忆配置** - 核心思想：Rules 只需要告诉 Agent ".memory 目录是什么、何时使用"，具体的使用方式和目录结构都在 .memory/README.md 中定义。这样做的好处：
   - 使用文件系统作为 Cursor 与文档的交互协议
   - Rules 不需要动态维护，记忆的使用规范可以在 .memory 中独立演进
   - Agent 通过读取 README.md 自然获取最新的使用说明

## 本地记忆的设计

```markdown
# Project Memory Knowledge Base

本目录是项目记忆库，用于存储 AI Agent 需要了解的项目知识。

## 🗂️ 记忆库结构
```
.memory/
├── README.md           # 本文件：记忆库说明和使用协议
├── index.md            # 总索引：所有主题快速入口
├── business-domain.md  # 业务知识（核心概念、业务规则）
├── key-features.md     # 核心功能（主要功能列表与实现要点）
└── troubleshooting.md  # 常见问题与解决方案
```

## 📖 使用协议

### 何时读取记忆
- 开始复杂任务前
- 涉及业务逻辑时
- 遇到不确定的实现细节时

### 何时更新记忆
- 完成重要功能后
- 解决棘手问题后
- 发现文档与实际不符时

### 导航方式
- 从 [[index]] 开始导航
- 每个主题一个文件，使用 `[[文件名]]` 相互链接
- 项目演进时及时更新，避免冗余

```
