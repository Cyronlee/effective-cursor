---
title: "Cursor 终于支持 Skills 了，一条命令从 Rules 迁移过去"
---

# Cursor 终于支持 Skills 了，一条命令从 Rules 迁移过去

**2026 年 1 月 22 日，Cursor 终于在正式版中推出了 Agent Skills 功能！**

这个功能在 nightly 通道测试了一段时间，现在所有用户都可以使用了。如果你已经在用 Cursor Rules 来定制 AI 的行为，那么恭喜你——你已经走在了大多数开发者前面。而 **Agent Skills** 带来了一种全新的扩展方式，可能会彻底改变你组织 AI 指令的方式。

这篇文章将帮助你理解 Rules 和 Skills 的本质区别，以及如何智能地进行迁移——**不是简单地把所有 Rules 都变成 Skills，而是让它们各得其所**。

## Rules 和 Skills：两种不同的扩展机制

先来明确一个核心概念：**Rules 和 Skills 不是替代关系，而是互补关系**。

### Rules：静态上下文

Rules 提供**持续生效的指令**，Agent 在每次对话开始时都会看到这些内容。适合：

- 🔧 **项目命令**：`npm run build`、`bun test` 等常用命令
- 📐 **代码风格**：ES 模块 vs CommonJS、命名规范等
- 📁 **项目结构**：API 路由放在哪、组件如何组织
- 🔗 **规范引用**：指向代码库中的标准示例文件

```markdown
# .cursor/rules/project-conventions.mdc
---
alwaysApply: true
---
# 项目规范

## 命令
- `bun run build` : 构建项目
- `bun run typecheck` : 类型检查
- `bun run test` : 运行测试

## 代码风格
- 使用 ES 模块(import/export)，而非 CommonJS(require)
- 参考 `components/Button.tsx` 了解标准组件结构

## 工作流
- 代码修改后始终运行类型检查
- API 路由放在 `app/api/` 目录
```

### Skills：动态能力

Skills 是**按需加载**的专业能力包，只有当 Agent 判断相关时才会加载。适合：

- ⚡ **自定义命令**：通过 `/命令名` 触发的可复用工作流
- 🔄 **自动化流程**：配合 Hooks 实现自动化
- 📚 **领域知识**：特定任务的详细指令（如部署流程、数据库迁移等）

```markdown
# .cursor/skills/deploy-app/SKILL.md
---
name: deploy-app
description: 将应用部署到预发布或生产环境。在部署代码、发布或切换环境时使用。
---
# 部署应用

使用以下脚本部署应用。

## 使用方式

运行部署脚本: `scripts/deploy.sh <environment>`

其中 `<environment>` 为 `staging` 或 `production`。

## 部署前验证

部署前先运行验证脚本: `python scripts/validate.py`
```

### 核心区别：上下文窗口的效率

| 特性 | Rules | Skills |
|------|-------|--------|
| 加载时机 | 每次对话开始 | 按需加载 |
| 上下文占用 | 始终占用 | 仅在需要时 |
| 适合内容 | 简短、高频使用 | 详细、特定场景 |
| 触发方式 | 自动应用 | Agent 判断 或 `/命令` |

如果你把所有内容都放在 Rules 里，Agent 的上下文窗口会被大量可能用不到的指令塞满。而 Skills 的按需加载机制，让你可以提供丰富的专业能力而不牺牲效率。

## 最佳实践：让 Rules 和 Skills 协同工作

### 从简单开始

只有当你发现 Agent 反复犯同样的错误时，再新增规则。在真正理解自己的模式之前，不要过度优化。观察 Agent 的行为，针对性地添加。

### Rules 保持简洁，Skills 提供细节

Rules 应该聚焦在要点上：引用文件而不是复制内容，列出关键命令和模式。不要复制整份风格指南（用 linter 代替），也不要记录所有可能的命令（Agent 已了解常用工具）。

相反，Skills 可以包含详细的分步指令、脚本引用、边界情况处理等。因为只在需要时加载，不用担心占用上下文。

### 提交到 Git，团队共享

将 Rules 和 Skills 都提交到 Git，让整个团队受益。当 Agent 犯错时，更新对应的规则或技能。

### 利用 Hooks 增强自动化

Skills 可以配合 Hooks 实现强大的自动化，比如：

```json
// .cursor/hooks.json
{
  "version": 1,
  "hooks": {
    "stop": [{
      "command": "bun run .cursor/hooks/verify-tests.ts"
    }]
  }
}
```

这个 Hook 可以让 Agent 持续工作直到所有测试通过。

## 官方migrate-to-skills命令

Cursor 2.4 内置了 `/migrate-to-skills` 命令，可以快速完成基础迁移。它的迁移策略比较直接：

**会迁移的**：
- 设置为"智能应用"的规则（有 `description`，无 `globs`，无 `alwaysApply: true`）
- 所有斜杠命令

**不会迁移的**：
- 设置了 `alwaysApply: true` 的规则
- 指定了 `globs` 模式的规则

## 智能迁移：让 Rules 和 Skills 各得其所

基于 [Cursor 官方最佳实践](https://cursor.com/cn/blog/agent-best-practices)，我设计了一个更智能的迁移策略。关键是理解内容的本质：如果是每次对话都需要的规范性指导，保留为 Rules；如果是特定场景下的详细操作流程，迁移为 Skills。

### 判断标准

**保留为 Rules**：项目命令清单（build、test、lint）、代码风格规范（命名、导入、文件组织）、规范文件引用（指向标准示例）、工作流指令（如"修改后运行类型检查"）以及简短且高频使用的内容。

**迁移为 Skills**：详细的多步骤操作流程（部署、发布、数据库迁移）、特定场景才需要的指令、可复用的工作流（PR、Issue、代码审查）、包含脚本执行的能力，以及超过 50 行的详细指南。

### 智能迁移提示词

在 Agent 聊天中输入以下提示词，执行智能迁移分析：

````markdown
## 任务：智能分析并迁移 Cursor Rules 到 Skills

请分析项目中的所有 Cursor Rules，根据最佳实践决定哪些应该迁移为 Skills，哪些应该保留为 Rules。

### 分析范围

扫描以下位置的规则文件：
- 项目级：`{workspaceFolder}/**/.cursor/rules/*.mdc`
- 项目命令：`{workspaceFolder}/**/.cursor/commands/*.md`
- 用户命令：`~/.cursor/commands/*.md`

忽略：
- `~/.cursor/worktrees` 目录
- `~/.cursor/skills-cursor` 目录（系统内置）

### 分类标准

**保留为 Rules**：项目命令清单、代码风格规范、规范文件引用、简短工作流指令（< 30 行）、高频内容、已设置 `alwaysApply: true` 的规则、指定了 `globs` 模式的规则。

**迁移为 Skills**：详细的多步骤流程、特定场景指令、可复用工作流、包含脚本的流程、内容较长（> 50 行）的指南、斜杠命令。

### 执行步骤

1. **扫描阶段**：列出并读取所有规则和命令文件

2. **分析阶段**：对每个文件分类并输出表格

   | 文件 | 当前类型 | 建议 | 原因 |
   |------|----------|------|------|
   | xxx.mdc | Rule | 保留 | 包含项目命令清单，高频使用 |
   | yyy.mdc | Rule | 迁移 | 详细的部署流程，特定场景使用 |

3. **确认阶段**：展示分析结果，等待用户确认

4. **执行阶段**（用户确认后）：
   - 迁移的文件：在 `.cursor/skills/{name}/` 创建 `SKILL.md`，保留原始内容，添加正确的 frontmatter（斜杠命令添加 `disable-model-invocation: true`），删除原文件
   - 保留的文件：不做修改，如适合则建议添加 `alwaysApply: true`

5. **报告阶段**：输出迁移摘要、新创建的 Skills、保留的 Rules 和撤销说明

### SKILL.md 格式

```markdown
---
name: skill-name
description: 描述此技能的功能及使用时机
disable-model-invocation: true  # 仅斜杠命令添加此行
---
# 标题

原始内容（保持不变）...
```

### 注意事项

- `name` 字段必须是小写字母和连字符
- `description` 是 Agent 发现技能的关键，务必准确描述
- **严格保留原始内容**，不要修改、重排或"改进"
- 如果用户要求撤销，执行反向操作恢复原文件
````

### 迁移示例

假设你有这样的 Rules 结构：

```
.cursor/rules/
├── project-commands.mdc      # 项目命令清单
├── code-style.mdc            # 代码风格规范
├── deployment-guide.mdc      # 详细的部署流程
├── api-conventions.mdc       # API 约定（针对 *.api.ts）
└── pr-workflow.mdc           # PR 创建工作流
```

智能迁移后：

```
.cursor/
├── rules/
│   ├── project-commands.mdc  # 保留 - 高频使用的命令
│   ├── code-style.mdc        # 保留 - 代码风格规范
│   └── api-conventions.mdc   # 保留 - 有 globs 限定
└── skills/
    ├── deployment-guide/
    │   └── SKILL.md          # 迁移 - 详细流程，特定场景
    └── pr-workflow/
        └── SKILL.md          # 迁移 - 可复用工作流
```

## 进阶：从代码库自动提取 Rules 和 Skills

如果你是从零开始，或者想让 Cursor 自动分析你的项目并生成合适的 Rules 和 Skills，可以使用以下提示词。这个命令会扫描你的代码库，分析项目结构、技术栈、配置文件和代码模式，然后自动生成项目级的规范和可复用的工作流。

### 代码库扫描提示词

在 Agent 聊天中输入：

````markdown
## 任务：扫描代码库，自动提取 Rules 和 Skills

请全面分析当前项目的代码库，自动生成合适的 Cursor Rules 和 Agent Skills。

### 第一步：项目分析

扫描并分析以下内容：

**项目配置**：`package.json`、`tsconfig.json`、`.eslintrc`、`Dockerfile`、CI/CD 配置文件等

**项目结构**：目录组织、文件命名约定、模块划分模式

**代码模式**：导入/导出风格、组件结构、状态管理、API 调用模式、错误处理、测试组织方式

**常用命令**：从 package.json scripts、Makefile、README 提取

**现有规范文档**：README.md、CONTRIBUTING.md、docs/ 目录、已有的 .cursor/rules/

### 第二步：生成 Rules

根据分析结果，生成以下 Rules（放在 `.cursor/rules/` 目录）：

**project-overview.mdc**（始终应用）
```markdown
---
alwaysApply: true
---
# 项目概述

## 技术栈
[从分析中提取]

## 项目结构
[从分析中提取目录说明]

## 常用命令
[从 package.json scripts 等提取]
```

**code-style.mdc**（始终应用）
```markdown
---
alwaysApply: true
---
# 代码风格

[从分析中提取的代码风格规范]
[引用项目中的规范示例文件]
```

**针对特定文件类型的 Rules**（使用 globs）
```markdown
---
globs: ["*.tsx", "*.jsx"]
---
# React 组件规范

[针对该文件类型的具体规范]
```

### 第三步：生成 Skills

根据分析结果，生成以下 Skills（放在 `.cursor/skills/` 目录）：

**根据项目类型生成对应的工作流 Skills**

如果是 Web 项目：`create-component/SKILL.md`、`create-api-route/SKILL.md`、`add-feature/SKILL.md`

如果有 CI/CD：`deploy/SKILL.md`、`release/SKILL.md`

如果有测试：`add-tests/SKILL.md`、`tdd/SKILL.md`

**Git 工作流 Skills**：`pr/SKILL.md`、`fix-issue/SKILL.md`

### 第四步：输出报告

完成后输出：

1. **分析摘要**：识别到的技术栈、代码模式、项目规范

2. **生成的文件列表**

   | 类型 | 文件路径 | 说明 |
   |------|----------|------|
   | Rule | .cursor/rules/xxx.mdc | 描述 |
   | Skill | .cursor/skills/xxx/SKILL.md | 描述 |

3. **建议**：可能需要手动补充的内容、推荐添加的额外 Rules 或 Skills

### 注意事项

- **不要复制整份文档**：Rules 应该引用文件，而不是复制内容
- **保持简洁**：Rules 聚焦要点，详细内容放到 Skills
- **使用规范示例**：在 Rules 中引用项目中的规范文件作为示例
- **遵循命名规范**：文件名使用 kebab-case，Skill name 使用小写字母和连字符
- **提供准确的 description**：这是 Agent 发现 Skill 的关键
````

### 使用示例

运行命令后，Cursor 会自动分析你的项目并生成类似这样的结构：

```
.cursor/
├── rules/
│   ├── project-overview.mdc     # 项目概述、技术栈、常用命令
│   ├── code-style.mdc           # 代码风格规范
│   ├── react-components.mdc     # React 组件规范 (globs: *.tsx)
│   └── api-routes.mdc           # API 路由规范 (globs: */api/*)
└── skills/
    ├── create-component/SKILL.md    # 创建组件的标准流程
    ├── create-api-route/SKILL.md    # 创建 API 路由的流程
    ├── pr/SKILL.md                  # 创建 PR 的流程
    └── deploy/SKILL.md              # 部署流程
```

这样，你就拥有了一个根据项目实际情况定制的 Cursor 配置，而不是从网上复制来的通用模板。

## 总结

| | Rules | Skills |
|---|-------|--------|
| **定位** | 静态上下文 | 动态能力 |
| **加载** | 每次对话 | 按需加载 |
| **适合** | 简短、高频、规范性 | 详细、特定场景、流程性 |
| **格式** | `.mdc` 文件 | `SKILL.md` + 可选脚本 |
| **触发** | 自动/Globs | Agent 判断 / `/命令` |

**迁移不是目的，让 AI 更高效地理解和执行你的意图才是目的**。本文提供了两个实用提示词：智能迁移命令（分析现有 Rules，智能决定保留还是迁移）和代码库扫描命令（从零开始，自动提取项目规范生成 Rules 和 Skills）。让你的 Rules 和 Skills 各司其职，构建一个高效的 Cursor 开发环境。

---

> 📌 **提示**：Agent Skills 功能需要 Cursor 2.4 及以上版本。

> 💬 有问题或建议？欢迎在评论区交流，或提交 Issue 到 [GitHub 仓库](https://github.com/cyronlee/effective-cursor)。
