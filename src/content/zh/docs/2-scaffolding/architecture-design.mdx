---
title: "架构设计"
---

# 架构设计

> 为 AI 开发提供良好的架构基础

为 AI 开发设计的架构不是让 AI "自由发挥"，而是构建一个**严密规则 + 快速反馈 + 小步迭代**的约束环境，让 AI Agent 在安全轨道上高效运行。

## 模块化设计

模块化是 AI 友好架构的基石。每个模块应该：

- **职责单一**：只做一件事，做好它
- **边界清晰**：明确的输入输出
- **依赖明确**：清晰的依赖关系图

### 前端模块化示例

```
src/
├── features/              # 功能模块（按业务领域划分）
│   ├── auth/
│   │   ├── components/    # 模块内组件
│   │   │   ├── LoginForm.tsx
│   │   │   └── SignupForm.tsx
│   │   ├── hooks/         # 模块内 hooks
│   │   │   └── useAuth.ts
│   │   ├── api/           # 模块内 API 调用
│   │   │   └── authApi.ts
│   │   ├── types.ts       # 模块内类型定义
│   │   └── index.ts       # 模块公开接口
│   └── dashboard/
│       └── ...
├── shared/                # 跨模块共享
│   ├── ui/               # 通用 UI 组件
│   ├── hooks/            # 通用 hooks
│   └── utils/            # 工具函数
└── core/                  # 核心基础设施
    ├── api/              # API 客户端配置
    ├── config/           # 应用配置
    └── providers/        # Context Providers
```

### 后端模块化示例

```
src/
├── modules/              # 业务模块
│   ├── user/
│   │   ├── user.controller.ts
│   │   ├── user.service.ts
│   │   ├── user.repository.ts
│   │   ├── user.entity.ts
│   │   ├── user.dto.ts
│   │   └── user.module.ts
│   └── order/
│       └── ...
├── common/               # 公共模块
│   ├── decorators/
│   ├── guards/
│   ├── interceptors/
│   └── filters/
└── infrastructure/       # 基础设施
    ├── database/
    ├── cache/
    └── messaging/
```

## 目录结构规范

### 命名约定

| 类型 | 规范 | 示例 |
|-----|------|-----|
| 文件夹 | kebab-case | `user-management/` |
| 组件文件 | PascalCase | `UserProfile.tsx` |
| 工具函数 | camelCase | `formatDate.ts` |
| 类型文件 | kebab-case | `user.types.ts` |
| 测试文件 | 原文件名 + .test | `UserProfile.test.tsx` |

### 入口文件约定

每个模块使用 `index.ts` 作为公开接口：

```typescript
// features/auth/index.ts
export { LoginForm } from './components/LoginForm';
export { useAuth } from './hooks/useAuth';
export type { User, AuthState } from './types';

// 不导出内部实现细节
```

## 强类型系统

类型是 AI 理解代码的最佳指南。

### TypeScript 最佳实践

```typescript
// ✅ 好的做法：明确的类型定义
interface CreateUserInput {
  email: string;
  password: string;
  name: string;
  role?: UserRole;
}

interface User {
  id: string;
  email: string;
  name: string;
  role: UserRole;
  createdAt: Date;
  updatedAt: Date;
}

type UserRole = 'admin' | 'user' | 'guest';

// AI 能准确理解函数签名
async function createUser(input: CreateUserInput): Promise<User> {
  // 实现...
}

// ❌ 避免的做法：any 类型
async function createUser(input: any): Promise<any> {
  // AI 无法理解预期行为
}
```

### 类型驱动开发

```typescript
// 1. 先定义类型契约
interface OrderService {
  createOrder(items: OrderItem[]): Promise<Order>;
  getOrder(id: string): Promise<Order | null>;
  cancelOrder(id: string): Promise<void>;
}

// 2. AI 根据契约实现
class OrderServiceImpl implements OrderService {
  async createOrder(items: OrderItem[]): Promise<Order> {
    // AI 可以准确实现，因为类型清晰
  }
  // ...
}
```

## 接口与契约

### API 契约定义

使用 OpenAPI/Swagger 或 tRPC 定义清晰的 API 契约：

```typescript
// tRPC 示例：类型安全的 API
import { z } from 'zod';
import { router, publicProcedure } from './trpc';

const userRouter = router({
  getUser: publicProcedure
    .input(z.object({ id: z.string() }))
    .output(z.object({
      id: z.string(),
      name: z.string(),
      email: z.string(),
    }))
    .query(async ({ input }) => {
      // 类型完全推导
    }),

  createUser: publicProcedure
    .input(z.object({
      name: z.string().min(2),
      email: z.string().email(),
    }))
    .mutation(async ({ input }) => {
      // AI 知道 input 的精确类型
    }),
});
```

### 数据库 Schema 契约

```typescript
// Prisma Schema 示例
model User {
  id        String   @id @default(cuid())
  email     String   @unique
  name      String
  posts     Post[]
  profile   Profile?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// 自动生成的类型可直接使用
import { User, Post } from '@prisma/client';
```

## 文档与自描述性

### 自描述的代码

```typescript
// 使用 JSDoc 增强 AI 理解
/**
 * 创建新用户账户
 * @param input - 用户注册信息
 * @returns 创建的用户对象（不含密码）
 * @throws {ConflictError} 当邮箱已被注册时
 * @example
 * const user = await createUser({
 *   email: 'user@example.com',
 *   password: 'securePassword123',
 *   name: 'John Doe'
 * });
 */
async function createUser(input: CreateUserInput): Promise<User> {
  // AI 能从文档理解边界条件和预期行为
}
```

### README 驱动开发

每个模块应有简洁的 README：

```markdown
# Auth Module

## 职责
处理用户认证、授权和会话管理。

## 主要导出
- `LoginForm` - 登录表单组件
- `useAuth` - 认证状态 hook
- `authApi` - 认证 API 客户端

## 依赖
- `@/core/api` - API 基础设施
- `@/shared/ui` - 通用 UI 组件

## 使用示例
\```tsx
import { LoginForm, useAuth } from '@/features/auth';

function App() {
  const { user, isLoading } = useAuth();
  // ...
}
\```
```

## 架构检查清单

在开始 AI 辅助开发前，确保：

- [ ] 目录结构已规划，遵循模块化原则
- [ ] TypeScript 严格模式已启用
- [ ] 核心类型和接口已定义
- [ ] API 契约已明确
- [ ] 数据库 Schema 已设计
- [ ] 公共模块和工具函数已组织
- [ ] 代码规范已配置（ESLint、Prettier）

## 下一步

架构设计完成后，接下来配置[静态分析工具](./static-analysis)来提供实时反馈。

