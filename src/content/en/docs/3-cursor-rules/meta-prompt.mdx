---
title: "Meta Prompts for Generating Rules"
---

import { Callout, Tabs } from 'nextra/components'

# Meta Prompts for Generating Rules

> Use AI to help you write AI rules

## Why Meta Prompts

When facing a new project or tech stack, writing Cursor Rules from scratch can be overwhelming. **Meta Prompts** can help you:

- Quickly generate rule frameworks
- Ensure rules cover key areas
- Maintain consistency in rule format

<Callout type="info">
Meta prompts are essentially "prompts for generating prompts". You tell AI about your project, and AI helps you generate suitable Cursor Rules.
</Callout>

## Universal Meta Prompt Template

Here's a proven meta prompt template to help you quickly generate project rules:

<Tabs items={['English', '中文版']}>
<Tabs.Tab>

```markdown
# Task
Generate Cursor Rules files for my project.

# Project Info
- Tech Stack: [List your tech stack, e.g., React, TypeScript, Tailwind CSS, Zustand]
- Framework: [List main frameworks, e.g., Vite, Next.js, Express]
- UI Library: [e.g., Shadcn/UI, Ant Design, Material UI]
- Project Type: [e.g., Web App, Admin Dashboard, Mobile H5]

# Directory Structure
[Paste your project directory structure]

# Rule Requirements
1. Generate global-rules.mdc: Include tech stack, directory structure, TypeScript standards, import conventions
2. Generate specific rule files for main functional modules
3. Each rule must be specific and actionable, avoid vague descriptions
4. Include code examples with import paths
5. Use appropriate globs and alwaysApply configurations

# Output Format
Output complete content for each rule file in .mdc format with frontmatter.
```

</Tabs.Tab>
<Tabs.Tab>

```markdown
# 任务
为我的项目生成 Cursor Rules 规则文件。

# 项目信息
- 技术栈：[列出你的技术栈，如 React, TypeScript, Tailwind CSS, Zustand]
- 框架：[列出主要框架，如 Vite, Next.js, Express]
- UI 库：[如 Shadcn/UI, Ant Design, Material UI]
- 项目类型：[如 Web 应用、管理后台、移动端 H5]

# 目录结构
[粘贴你的项目目录结构]

# 规则要求
1. 生成 global-rules.mdc：包含技术栈、目录结构、TypeScript 规范、导入约定
2. 针对主要功能模块生成专门的规则文件
3. 每条规则必须具体、可执行，避免泛泛描述
4. 包含代码示例，指明 import 路径
5. 使用合适的 globs 和 alwaysApply 配置

# 输出格式
为每个规则文件输出完整内容，使用 .mdc 格式，包含 frontmatter。
```

</Tabs.Tab>
</Tabs>

## Usage Example

### Step 1: Gather Project Information

First, collect key information about your project:

```bash
# Get directory structure
tree src -L 2 -I 'node_modules|dist'

# Check dependencies in package.json
cat package.json | jq '.dependencies, .devDependencies'
```

### Step 2: Fill in the Template

```markdown
# Task
Generate Cursor Rules files for my project.

# Project Info
- Tech Stack: React 18, TypeScript 5, Tailwind CSS 3
- Framework: Vite 5
- UI Library: Shadcn/UI
- State Management: Zustand
- Data Fetching: SWR
- Authentication: Okta
- Project Type: Enterprise Admin Dashboard

# Directory Structure
src/
├── pages/           # Route pages
├── components/      # UI components
│   ├── ui/          # Shadcn base components
│   └── features/    # Business components
├── lib/             # Utilities
├── stores/          # Zustand stores
├── clients/         # API clients
├── hooks/           # Custom Hooks
└── types/           # TypeScript types

# Rule Requirements
...
```

### Step 3: Iterate and Refine

Rules generated by AI may not fully match your needs, you'll need to:

1. **Review**: Check if rules match actual project situation
2. **Supplement**: Add project-specific standards AI missed
3. **Test**: Have AI generate code based on rules, verify effectiveness
4. **Adjust**: Optimize rules based on test results

## Prompts for Specific Scenarios

### Generate API Rules

```markdown
Analyze my API client code and generate api-rules.mdc:

1. Identify HTTP client usage patterns
2. Summarize standard data fetching flow (e.g., SWR)
3. Extract unified error handling approach
4. Include complete code examples

Reference code:
[Paste your API client code]
```

### Generate UI Rules

```markdown
Based on my UI component library, generate ui-rules.mdc:

1. Define base component usage standards
2. Specify icon library and usage
3. Standardize notification/Toast usage
4. List components or patterns to avoid

UI Library: Shadcn/UI
Icon Library: Lucide React
Notification Library: Sonner
```

### Generate Testing Rules

```markdown
Generate testing-rules.mdc for my project:

1. Testing framework: [Vitest/Jest]
2. Test file location and naming conventions
3. Standard structure for unit tests
4. Mock usage standards
5. Test coverage requirements
```

## Rule Quality Checklist

After generating rules, use this checklist to verify quality:

| Check Item | Standard |
|------------|----------|
| **Specificity** | Is each rule directly actionable? |
| **Necessity** | Has common knowledge been removed? |
| **Examples** | Do key rules have code examples? |
| **Paths** | Are import paths accurate? |
| **Scope** | Are globs configured correctly? |

<Callout type="warning">
Rules generated by meta prompts are just a starting point, not the end. Truly effective rules come from continuous iteration during actual development.
</Callout>

## Reference Resources

- [Cursor Rules Best Practices](./best-practices) - Core principles for rule writing
- [Rules Development Sequence](./development-sequence) - When to write what rules
- [Vite + Shadcn/UI Rule Set](/en/rules/vite-shadcnui) - Complete rule examples

## Next Steps

After completing your Rules, let's move on to [Chapter 4: Workflow](../4-workflow) to learn how to integrate these rules into your daily development process.

