---
title: "Meta Prompts for Generating Rules"
---

import { Callout, Tabs } from 'nextra/components'

# Meta Prompts for Generating Rules

> Use AI to help you write AI rules

## What is a Meta Prompt

When facing a new project or tech stack, writing Cursor Rules from scratch can be overwhelming. **Meta Prompts** are essentially "prompts for generating prompts"—you tell AI about your project, and AI helps you generate suitable Cursor Rules.

<Callout type="info">
Meta prompts help you quickly generate rule frameworks, ensure rules cover key areas, and maintain format consistency. But they're just a starting point—truly effective rules come from continuous iteration during actual development.
</Callout>

## Complete Examples

We've prepared complete rule extraction templates and examples for common tech stacks:

- **[Vite + Shadcn/UI Rule Set](/en/rules/vite-shadcnui)** - Frontend project rule extraction template with 4 rule file examples
- **[Spring Boot Rule Set](/en/rules/springboot)** - Backend project rule extraction template with 5 rule file examples

These examples include complete prompt templates for extracting standards from projects, ready to use or adapt to your tech stack.

## Quick Start: Three Steps to Generate Rules

### Step 1: Gather Project Information

Collect key information about your project:

```bash
# Get directory structure
tree src -L 2 -I 'node_modules|dist'
```

### Step 2: Choose and Fill in Template

Based on your tech stack, choose an appropriate extraction template from the examples above, or use this universal template:

<Tabs items={['English', '中文版']}>
<Tabs.Tab>

```markdown
# Task
Generate Cursor Rules files for my project.

# Project Info
- Tech Stack: [e.g., React, TypeScript, Tailwind CSS]
- Framework: [e.g., Vite, Next.js, Spring Boot]
- Project Type: [e.g., Web App, Admin Dashboard, REST API]

# Directory Structure
[Paste your project directory structure]

# Rule Requirements
1. Generate global-rules.mdc: Include tech stack, directory structure, language standards, import conventions
2. Generate specific rule files for main modules (e.g., routing, UI, API, testing)
3. Only write rules that actually exist and are enforced in the project, not LLM common knowledge
4. Each rule must be specific and actionable, avoid vague descriptions
5. Include code examples (3~10 lines) only when necessary
6. Use appropriate globs and alwaysApply configurations

# Output Format
Output complete content for each rule file in .mdc format with frontmatter.
```

</Tabs.Tab>
<Tabs.Tab>

```markdown
# 任务
为我的项目生成 Cursor Rules 规则文件。

# 项目信息
- 技术栈：[列出你的技术栈，如 React, TypeScript, Tailwind CSS]
- 框架：[列出主要框架，如 Vite, Next.js, Spring Boot]
- 项目类型：[如 Web 应用、管理后台、REST API]

# 目录结构
[粘贴你的项目目录结构]

# 规则要求
1. 生成 global-rules.mdc：包含技术栈、目录结构、语言规范、导入约定
2. 针对主要功能模块生成专门的规则文件（如路由、UI、API、测试等）
3. 只写项目中真实存在且被反复强制使用的规范，不要写大模型常识
4. 每条规则必须具体、可执行，避免泛泛描述
5. 仅在必要时附上代码示例（3~10 行）
6. 使用合适的 globs 和 alwaysApply 配置

# 输出格式
为每个规则文件输出完整内容，使用 .mdc 格式，包含 frontmatter。
```

</Tabs.Tab>
</Tabs>

### Step 3: Iterate and Refine

AI-generated rules need validation and improvement:

1. **Review** - Check if rules match actual project situation
2. **Supplement** - Add project-specific standards AI missed
3. **Test** - Have AI generate code based on rules, verify effectiveness
4. **Adjust** - Optimize rules based on test results

## Prompts for Specific Modules

Sometimes you only need to generate or update rules for specific modules:

### Generate API Rules

```markdown
Analyze my API client code and generate api-rules.mdc:

1. Identify HTTP client usage patterns
2. Summarize standard data fetching flow (e.g., SWR, React Query)
3. Extract unified error handling approach
4. Include complete code examples

Reference code:
[Paste your API client code]
```

### Generate UI Rules

```markdown
Based on my UI component library, generate ui-rules.mdc:

1. Define base component usage standards
2. Specify icon library and usage
3. Standardize notification/Toast usage
4. List components or patterns to avoid

UI Library: [Shadcn/UI / Ant Design / Material UI]
Icon Library: [Lucide / Iconify]
Notification Library: [Sonner / React Hot Toast]
```

### Generate Testing Rules

```markdown
Generate testing-rules.mdc for my project:

1. Testing framework: [Vitest / Jest / JUnit]
2. Test file location and naming conventions
3. Standard structure for tests
4. Mock usage standards
5. Test coverage requirements
```

## Rule Quality Checklist

After generating rules, verify quality with this checklist:

| Check Item | Standard |
|------------|----------|
| **Specificity** | Is each rule directly actionable? |
| **Necessity** | Has common knowledge been removed? |
| **Examples** | Do key rules have code examples? |
| **Paths** | Are import paths accurate? |
| **Scope** | Are globs configured correctly? |

<Callout type="warning">
Avoid writing "components should be single-purpose", "use ESLint", "function names should be semantic"—LLMs already know this. Only write project-specific rules that AI cannot infer.
</Callout>

## Reference Resources

- [Cursor Rules Best Practices](./best-practices) - Core principles for rule writing
- [Rules Development Sequence](./development-sequence) - When to write what rules
- [Vite + Shadcn/UI Rule Set](/en/rules/vite-shadcnui) - Complete frontend rule examples
- [Spring Boot Rule Set](/en/rules/springboot) - Complete backend rule examples

## Next Steps

After completing your Rules, let's move on to [Chapter 4: Workflow](../4-workflow) to learn how to integrate these rules into your daily development process.

